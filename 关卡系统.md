# 关卡系统设计说明（细化版）

## 目标
关卡系统负责驱动文本 RPG 的闯关流程，包含关卡生成、节点推进、事件触发、奖励结算与日志记录。系统支持无尽模式、可配置关卡数量、固定随机种子回放与完整路径追踪。

## 核心原则
- 无尽模式：关卡可循环或动态生成，支持难度递增。
- 可配置：关卡/节点/事件均可通过 JSON 扩展。
- 可复现：支持固定随机种子，保证测试与回放一致。
- 可追溯：记录节点路径、事件结果与奖励日志。
- 高容错：关卡配置异常时自动降级，并输出详细日志。

## 数据模型
### Stage（关卡实例）
- id：关卡唯一 ID
- name：关卡名称
- chapter：章节编号
- difficulty：关卡难度
- floors：层数/轮次
- nodes：节点 ID 列表
- entry / exit：入口/出口节点
- command：关卡口令（剧情/彩蛋）
- guardianPool：关卡守卫可选敌群

### Node（节点定义）
- id：节点 ID
- type：节点类型（BATTLE/TRAP/SHOP/REST/STORY 等）
- neighbors：相邻节点 ID
- eventId：绑定事件 ID（可空）
- conditions：进入条件列表
- weight：权重（用于随机挑选）
- tags：标签列表（拓展用）
- hidden：是否为隐藏节点

### StageRuntime（运行时）
- currentNodeId：当前节点
- visited：已访问节点集合
- path：实际路径（保留顺序）
- completed：是否完成
- lastMoveReason：最后一次移动原因（用于日志）

### StageContext（上下文）
- chapter：章节
- difficulty：难度
- turn：当前回合

## 推进流程
1. startStageForChapter：根据章节/难度选择关卡，并初始化入口节点。
2. enterNode：进入节点并触发事件。
3. resolveOption：选择选项并结算结果。
4. moveToNextNode：从当前节点推进到下一个节点。
5. advance：进入下一节点或结束关卡。

## 节点选择策略
1. 计算邻接节点（只保留当前关卡内节点）。
2. 按条件过滤可进入节点。
3. 优先选择未访问节点。
4. 若无未访问节点，按权重随机选择已访问节点。
5. 条件全部不满足时，记录警告并退化为无条件随机。

## 普通模式关卡规则（严格执行）
- 章节范围：第 1 章到第 10 章。
- 每章 10 小节（节点编号 1-1 ~ 1-10，2-1 ~ 2-10 ... 10-10）。
- 小节 1：普通怪。
- 小节 2：普通怪。
- 小节 3：精英怪。
- 小节 4：普通怪。
- 小节 5：普通怪。
- 小节 6：精英怪。
- 小节 7：普通怪。
- 小节 8：普通怪。
- 小节 9：精英怪。
- 小节 10：Boss。
- 精英怪与 Boss 战后触发商店事件，玩家可使用金币购买装备。
- 商店事件不会替代章节小节节点，需在商店结束后继续推进。

## 条件语法（conditions）
条件用于控制节点是否可进入，格式为字符串列表：
- `visited:<nodeId>`：已访问指定节点
- `not_visited:<nodeId>`：未访问指定节点
- `turn>=N` / `turn<=N`：回合数条件
- `chapter>=N` / `chapter<=N`：章节条件
- `difficulty>=N` / `difficulty<=N`：难度条件
- `chance:0.3` / `chance:30`：概率条件（0-1 或 0-100）

未知条件将写入日志并默认放行。

## 关卡校验
系统会在启动时执行关卡校验，输出问题日志：
- 入口/出口是否存在
- 节点是否存在
- 邻接是否越界
- 是否出现非出口死路
- 出口是否可达

若关卡异常，将自动归一化节点列表，或回退到默认关卡。

## 日志与回放
- 记录路径：节点进入顺序、分支选择、隐藏节点触发。
- 记录事件：事件结果、奖励摘要、战斗结算。
- 记录校验：关卡完整性问题与自动修复动作。

## JSON 配置示例
### stages.json
```json
{
  "schema": "stages.v1",
  "stages": [
    {
      "id": "stage_1",
      "name": "第一章：丛林试炼",
      "chapter": 1,
      "difficulty": 1,
      "floors": 1,
      "nodes": ["1-1", "1-2", "1-3"],
      "entry": "1-1",
      "exit": "1-3",
      "command": "JUNGLE-01",
      "guardianPool": []
    }
  ]
}
```

### nodes.json
```json
{
  "schema": "nodes.v1",
  "nodes": [
    {
      "id": "1-1",
      "type": "BATTLE",
      "neighbors": ["1-2"],
      "eventId": null,
      "conditions": [],
      "weight": 1,
      "tags": ["intro"],
      "hidden": false
    },
    {
      "id": "1-2",
      "type": "REST",
      "neighbors": ["1-3"],
      "eventId": null,
      "conditions": ["turn>=2"],
      "weight": 2,
      "tags": ["heal"],
      "hidden": false
    },
    {
      "id": "1-3",
      "type": "BATTLE",
      "neighbors": [],
      "eventId": null,
      "conditions": [],
      "weight": 1,
      "tags": ["boss"],
      "hidden": false
    }
  ]
}
```

## 与引擎接口
- `startStageForChapter(chapter, rng, difficulty)`
- `moveToNextNode(runtime, rng, context)`
- `moveToNode(runtime, nodeId)`
- `eventForNode(runtime, chapter, rng)`
- `restoreStage(...)`

## 测试要点
- 节点图连通性与无死路校验
- 条件语法解析与概率触发
- 未访问优先与权重随机
- 固定种子下的可复现实例流程
